# 程序框架梳理
    此乃本游戏程序的总框架，所有人都要在这里说明自己所负责的游戏层的核心内容
## UI层  &nbsp;&nbsp;&nbsp;&nbsp; @柯克兰 &nbsp; @灼华
- 负责提供玩家操作界面和监听玩家行为，并将行为指令提供给规则层
- 伪代码
```
#战斗部分

start（接收到事件，战斗开始）
{
       显示所有不变的UI//如背包按钮等
       while（战斗未结束）
       {
                规则层：获取角色行动先后；
                显示时间轴于屏幕上方；
                获取当前行动的人物坐标，在该坐标设置行动选项界面；
                获取剩余行动点，信息版面，并全部显示；
                while（接收到玩家指令）
                {
                         if（该指令并非战斗指令）
                         发送给规则层并执行；
                         else
                         {
                                  发送给规则层；
                                  显示掷骰结果和战斗结果；
                                  break；
                         }
                }
       }
}
update（接收到战斗结果）
{
       显示战斗结果；
       退出并终止战斗界面；
}

#探索部分

start（）
{
       显示常规UI；
       while（时间条未超出最大值）
       {
                if （玩家选择行动需消耗时间）
                {
                          if（剩余时间不足以执行）
                          {
                                   提示；
                                   continue；
                          }
                          else
                          弹出提示，确认后发送给数据层，修改进度条；
                }
                switch（所点击物品类型）
                {
                          执行；
                }
       }
}
```
- 成分分析：
    - 玩家行为的监听：
        - 鼠标点击选择框(特例：点击砖块的移动不在此列，由实例层负责)
        - 玩家快捷键的设置
    - 规则层的调用
        - 模式的切换：战斗模式和探索模式的切换
        ```C#
        //UI层中的示例代码
        public enum gameMode{
            battleMode,
            searchMode
        }

        public void switchModeTo(gameMonde _gameMode)
        {
            UI.switchMode(_gameMode);
            rule.switchMode(_gameMode);
        }

        //规则层(rule)中的示例代码
        public void switchMode(UI.gameMode _gameMode)
        {
            //一系列操作，或者改变关键指示变量
            chessBoard.switchMode();
            //调用实例层
        }
        //实例层代码
        //如上
        ```

- 调用关系声明:
    - UI层给予玩家操作指示，规则层判断玩家的操作合法性和判断玩家操作的后果，两个游戏层实质上是高度耦合的。在程序组内部会议中，模拟了两个层相互调用的模式——玩家操作时，由UI层调用规则层的函数，规则层的函数返回UI层需要的新参数。敌方(敌人AI)行动时，由规则层调用UI层变量，将数值变化呈现给玩家
## 规则层 &nbsp;&nbsp;&nbsp;&nbsp;  @啊哈 &nbsp; @暴走の扎克
- 负责检查玩家行为的合法性，计算玩家造成的伤害，根据玩家的行为记录为玩家触发事件等
- 伪代码
战斗：

start（）
{
         	从系统层传入玩家各角色基本属性和装备
	从系统层传入角色以及敌人坐标
	从系统层传入时间、行动点、玩家基本信息等并将部分信息传给UI层显示
	
	while（接收到UI的操作指令）
	{
		if（指令不合法）
		{
			continue；
		}
		else （指令合法）
		{
			example：
			if(移动位置)
			{
					
			}
			if(发动技能A)
			{
				if（判断技能可以释放）
				{
					根据骰点结果，各属性值计算得到伤害值
					返回UI层显示结果
					返回实例层显示动画
					返回系统层记录信息break；
				}	
				else
				{
					返回UI层提示玩家
				}
	
			}
			........（这里是n个if判断）
		}

	}
	
}
探索：
start（）
{
	while（收到UI层指令）
	{

		if（指令不合法)
		{
			continue；
			(返回UI层)
		}	
		else
		{
		玩家行为：
			if（行动）
			{
				
				发送位置信息给实例层，系统层
				if（触发事件）
				{
					发送指令给UI层，系统层，实例层
				}
				
			}
			else if（操作物品)  
			{
				从系统层调用物品信息（属性等）
				并发送给UI层
				
			}
		}	
	}
}
```C#
    战斗部分

start（接收到事件，战斗开始）
{
       从素材库中读取战斗地图，显示地图；//testMap()
       从规则层获取人物坐标；
       //公开变量
       在地图上显示人物；

       while（战斗未结束）
       {
            if（从规则层获取切换行动人物指令）；
            {
                从规则层获取当前行动的人物及其坐标，镜头移动至该坐标；
            }
            if（从规则层获取人物移动指令）；
            {
                播放人物移动动画，镜头跟随；
            }
            if（从规则层获取技能/攻击指令）；
            {
                从规则层获取攻击对象，掷骰结果，造成伤害；
                根据掷骰结果播放技能动画；//暴击，命中，miss
                根据造成伤害播放扣血动画；
            }
            if（从规则层接收人物阵亡信息）
            {
                人物从地图上消失//or修改人物立绘为倒下状态。
            }
            if（从规则层获取使用道具指令）
            {
                播放使用道具动画；
                if（是恢复类道具）
                    播放回血动画；
            }
            while（从UI层获得技能范围）
            {
                从规则层获取人物坐标
                在地图上高亮显示技能范围
            }         
       }
}


探索部分

start（）
{
       从素材库中读取地图，显示地图；
       从规则层获取人物、物品、npc初始坐标；
       在地图上显示人物、物品、npc；
}

update（）
{
       if（从规则层接受移动指令）
       {
                播放人物移动动画，根据当前速度方向更改人物朝向；
        }
}





```
## 实例层 &nbsp;&nbsp;&nbsp;&nbsp;  @okk &nbsp; @阿昆
- 负责为规则层提供棋盘行为的接口，导入来自美术组的特效
- chracterMove(人物移动)
    - 接口作用：调用时，使人物在棋盘上移动
    - 调用方法，详见```testController.cs```
    ```C#
    //_chracterMove = FindObjectOfType<chracterMove>();预载
        if (GUILayout.Button("W"))
        {
           _chracterMove.chracterMoveTo(chracterMove.direction.front);
        }
        if (GUILayout.Button("A"))
        {
            _chracterMove.chracterMoveTo(chracterMove.direction.left);
        }
        if (GUILayout.Button("S"))
        {
            _chracterMove.chracterMoveTo(chracterMove.direction.back);
        }
        if (GUILayout.Button("D"))
        {
            _chracterMove.chracterMoveTo(chracterMove.direction.right);
        }
    ```
## 系统层 &nbsp;&nbsp;&nbsp;&nbsp; @连续朋友      
- 负责游戏引擎和游戏底层数据的交互，为策划组提供虚拟指令集和配置文件接口，维护解释器，并为其他层提供封装成指定结构的数据
- map(地图)
  - 文件位于 PoiIn_battle-demo\Assets\testMap.json
  - "testMap"数组记录了砖块的虚拟位置和种类。 
    - 虚拟位置：即假设第一块砖块的位置为(0,0,0),每块砖块都为体积为1m^3的正方体时所得到的的砖块空间位置，如此可将所有砖块的位置整数化处理，便于后续的AI和规则层调用
    - 种类：将美术组提供的砖块编号后，以id的形式调用，id参考cubes文件夹中的cubesId.txt文件
    - 相关脚本：
        - ```chracter2Dposition.cs```<-仅封装了一个将虚拟位置转换为引擎实际位置的一个函数
        - ```loadMap.cs```<-提供json文件的解释器
        - ```testMap.cs``` 
- chracterCard(人物卡)
    - 文件位于 PoiIn_battle-demo\Assets\chracter
    - 用于将数据和引擎编码分离，提供人物的属性值和法术信息
        - 属性值：已经封装为了一个公共字典类型：
        - 法术列表：以封装为了一个公共链表，链表由spell结构体组成
        ```C#
        public Dictionary<string, int> status;
        //比如status["HP"]可取得HP值

        public struct spells
        {
            public string spellName;
            //法术的名称
            public string description;
            //法术的描述
            public Dictionary<string, int> Launching_Conditions;
            //法术发动的条件，后续会加入法术发动时造成的伤害加成和造成的特殊状态
        }
        //@啊哈@暴走の扎克
        public List<spells> spelleList = new List<spells>();
        //C#已经封装好的链表
        ```
        - 相关脚本:
            - ```chracterCard.cs```
            - ```castSpell.cs```
- sinario(对话脚本)
    - 文件位于PoiIn_battle-demo\Assets\testSinario
    - 规则参考 Gal脚本格式.md
    - 相关脚本：
        - ```textFileLoader.cs``` 
        - ```sinarioController.cs```
    - 脚手架：
    ```C#
    //_sinarioController = FindObjectOfType<sinarioController>();
        if (GUILayout.Button("nextSinario"))
        {
            _sinarioController.nextSinario();
        }
    ```
